Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    SEPARATOR

Grammar

Rule 0     S' -> programm
Rule 1     programm -> function
Rule 2     programm -> function programm
Rule 3     function -> FUNCTION signature L_BRACE body R_BRACE
Rule 4     signature -> IDENT L_BRACKET argumentList R_BRACKET
Rule 5     body -> infinstruction
Rule 6     argumentList -> IDENT
Rule 7     argumentList -> IDENT COMMA argumentList
Rule 8     argumentList -> <empty>
Rule 9     instruction -> assigment
Rule 10    instruction -> return
Rule 11    instruction -> condition
Rule 12    instruction -> loop
Rule 13    instruction -> <empty>
Rule 14    instruction -> assigment instruction
Rule 15    instruction -> return instruction
Rule 16    instruction -> condition instruction
Rule 17    instruction -> loop instruction
Rule 18    infinstruction -> infinstruction instruction
Rule 19    infinstruction -> instruction
Rule 20    assigment -> IDENT ASSIGN arExpression
Rule 21    return -> RETURN arExpression
Rule 22    condition -> IF arExpression L_BRACE instruction R_BRACE
Rule 23    condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
Rule 24    loop -> WHILE arExpression L_BRACE instruction R_BRACE
Rule 25    arExpression -> disjunct
Rule 26    arExpression -> disjunct OR arExpression
Rule 27    disjunct -> conjunct
Rule 28    disjunct -> conjunct AND disjunct
Rule 29    conjunct -> binaryExp
Rule 30    conjunct -> binaryExp BIN_OP binaryExp
Rule 31    binaryExp -> expression
Rule 32    binaryExp -> NOT expression
Rule 33    expression -> term
Rule 34    expression -> expression PLUS term
Rule 35    expression -> expression MINUS term
Rule 36    term -> factor
Rule 37    term -> term MUL_OP factor
Rule 38    factor -> base
Rule 39    factor -> MINUS factor
Rule 40    factor -> base FACTOR factor
Rule 41    base -> NUMBER
Rule 42    base -> IDENT
Rule 43    base -> L_BRACKET arExpression R_BRACKET
Rule 44    base -> signature

Terminals, with rules where they appear

AND                  : 28
ASSIGN               : 20
BIN_OP               : 30
COMMA                : 7
ELSE                 : 23
FACTOR               : 40
FUNCTION             : 3
IDENT                : 4 6 7 20 42
IF                   : 22 23
L_BRACE              : 3 22 23 23 24
L_BRACKET            : 4 43
MINUS                : 35 39
MUL_OP               : 37
NOT                  : 32
NUMBER               : 41
OR                   : 26
PLUS                 : 34
RETURN               : 21
R_BRACE              : 3 22 23 23 24
R_BRACKET            : 4 43
SEPARATOR            : 
WHILE                : 24
error                : 

Nonterminals, with rules where they appear

arExpression         : 20 21 22 23 24 26 43
argumentList         : 4 7
assigment            : 9 14
base                 : 38 40
binaryExp            : 29 30 30
body                 : 3
condition            : 11 16
conjunct             : 27 28
disjunct             : 25 26 28
expression           : 31 32 34 35
factor               : 36 37 39 40
function             : 1 2
infinstruction       : 5 18
instruction          : 14 15 16 17 18 19 22 23 23 24
loop                 : 12 17
programm             : 2 0
return               : 10 15
signature            : 3 44
term                 : 33 34 35 37

Parsing method: LALR

state 0

    (0) S' -> . programm
    (1) programm -> . function
    (2) programm -> . function programm
    (3) function -> . FUNCTION signature L_BRACE body R_BRACE

    FUNCTION        shift and go to state 3

    programm                       shift and go to state 1
    function                       shift and go to state 2

state 1

    (0) S' -> programm .



state 2

    (1) programm -> function .
    (2) programm -> function . programm
    (1) programm -> . function
    (2) programm -> . function programm
    (3) function -> . FUNCTION signature L_BRACE body R_BRACE

    $end            reduce using rule 1 (programm -> function .)
    FUNCTION        shift and go to state 3

    function                       shift and go to state 2
    programm                       shift and go to state 4

state 3

    (3) function -> FUNCTION . signature L_BRACE body R_BRACE
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    IDENT           shift and go to state 6

    signature                      shift and go to state 5

state 4

    (2) programm -> function programm .

    $end            reduce using rule 2 (programm -> function programm .)


state 5

    (3) function -> FUNCTION signature . L_BRACE body R_BRACE

    L_BRACE         shift and go to state 7


state 6

    (4) signature -> IDENT . L_BRACKET argumentList R_BRACKET

    L_BRACKET       shift and go to state 8


state 7

    (3) function -> FUNCTION signature L_BRACE . body R_BRACE
    (5) body -> . infinstruction
    (18) infinstruction -> . infinstruction instruction
    (19) infinstruction -> . instruction
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    R_BRACE         reduce using rule 13 (instruction -> .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

  ! IDENT           [ reduce using rule 13 (instruction -> .) ]
  ! RETURN          [ reduce using rule 13 (instruction -> .) ]
  ! IF              [ reduce using rule 13 (instruction -> .) ]
  ! WHILE           [ reduce using rule 13 (instruction -> .) ]

    body                           shift and go to state 9
    infinstruction                 shift and go to state 10
    instruction                    shift and go to state 11
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 8

    (4) signature -> IDENT L_BRACKET . argumentList R_BRACKET
    (6) argumentList -> . IDENT
    (7) argumentList -> . IDENT COMMA argumentList
    (8) argumentList -> .

    IDENT           shift and go to state 20
    R_BRACKET       reduce using rule 8 (argumentList -> .)

    argumentList                   shift and go to state 21

state 9

    (3) function -> FUNCTION signature L_BRACE body . R_BRACE

    R_BRACE         shift and go to state 22


state 10

    (5) body -> infinstruction .
    (18) infinstruction -> infinstruction . instruction
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

  ! reduce/reduce conflict for R_BRACE resolved using rule 5 (body -> infinstruction .)
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    R_BRACE         reduce using rule 5 (body -> infinstruction .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

  ! IDENT           [ reduce using rule 13 (instruction -> .) ]
  ! RETURN          [ reduce using rule 13 (instruction -> .) ]
  ! IF              [ reduce using rule 13 (instruction -> .) ]
  ! WHILE           [ reduce using rule 13 (instruction -> .) ]
  ! R_BRACE         [ reduce using rule 13 (instruction -> .) ]

    instruction                    shift and go to state 23
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 11

    (19) infinstruction -> instruction .

    IDENT           reduce using rule 19 (infinstruction -> instruction .)
    RETURN          reduce using rule 19 (infinstruction -> instruction .)
    IF              reduce using rule 19 (infinstruction -> instruction .)
    WHILE           reduce using rule 19 (infinstruction -> instruction .)
    R_BRACE         reduce using rule 19 (infinstruction -> instruction .)


state 12

    (9) instruction -> assigment .
    (14) instruction -> assigment . instruction
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

  ! reduce/reduce conflict for IDENT resolved using rule 9 (instruction -> assigment .)
  ! reduce/reduce conflict for RETURN resolved using rule 9 (instruction -> assigment .)
  ! reduce/reduce conflict for IF resolved using rule 9 (instruction -> assigment .)
  ! reduce/reduce conflict for WHILE resolved using rule 9 (instruction -> assigment .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 9 (instruction -> assigment .)
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    R_BRACE         reduce using rule 9 (instruction -> assigment .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

  ! IDENT           [ reduce using rule 9 (instruction -> assigment .) ]
  ! RETURN          [ reduce using rule 9 (instruction -> assigment .) ]
  ! IF              [ reduce using rule 9 (instruction -> assigment .) ]
  ! WHILE           [ reduce using rule 9 (instruction -> assigment .) ]
  ! IDENT           [ reduce using rule 13 (instruction -> .) ]
  ! RETURN          [ reduce using rule 13 (instruction -> .) ]
  ! IF              [ reduce using rule 13 (instruction -> .) ]
  ! WHILE           [ reduce using rule 13 (instruction -> .) ]
  ! R_BRACE         [ reduce using rule 13 (instruction -> .) ]

    assigment                      shift and go to state 12
    instruction                    shift and go to state 24
    return                         shift and go to state 13
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 13

    (10) instruction -> return .
    (15) instruction -> return . instruction
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

  ! reduce/reduce conflict for IDENT resolved using rule 10 (instruction -> return .)
  ! reduce/reduce conflict for RETURN resolved using rule 10 (instruction -> return .)
  ! reduce/reduce conflict for IF resolved using rule 10 (instruction -> return .)
  ! reduce/reduce conflict for WHILE resolved using rule 10 (instruction -> return .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 10 (instruction -> return .)
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    R_BRACE         reduce using rule 10 (instruction -> return .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

  ! IDENT           [ reduce using rule 10 (instruction -> return .) ]
  ! RETURN          [ reduce using rule 10 (instruction -> return .) ]
  ! IF              [ reduce using rule 10 (instruction -> return .) ]
  ! WHILE           [ reduce using rule 10 (instruction -> return .) ]
  ! IDENT           [ reduce using rule 13 (instruction -> .) ]
  ! RETURN          [ reduce using rule 13 (instruction -> .) ]
  ! IF              [ reduce using rule 13 (instruction -> .) ]
  ! WHILE           [ reduce using rule 13 (instruction -> .) ]
  ! R_BRACE         [ reduce using rule 13 (instruction -> .) ]

    return                         shift and go to state 13
    instruction                    shift and go to state 25
    assigment                      shift and go to state 12
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 14

    (11) instruction -> condition .
    (16) instruction -> condition . instruction
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

  ! reduce/reduce conflict for IDENT resolved using rule 11 (instruction -> condition .)
  ! reduce/reduce conflict for RETURN resolved using rule 11 (instruction -> condition .)
  ! reduce/reduce conflict for IF resolved using rule 11 (instruction -> condition .)
  ! reduce/reduce conflict for WHILE resolved using rule 11 (instruction -> condition .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 11 (instruction -> condition .)
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    R_BRACE         reduce using rule 11 (instruction -> condition .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

  ! IDENT           [ reduce using rule 11 (instruction -> condition .) ]
  ! RETURN          [ reduce using rule 11 (instruction -> condition .) ]
  ! IF              [ reduce using rule 11 (instruction -> condition .) ]
  ! WHILE           [ reduce using rule 11 (instruction -> condition .) ]
  ! IDENT           [ reduce using rule 13 (instruction -> .) ]
  ! RETURN          [ reduce using rule 13 (instruction -> .) ]
  ! IF              [ reduce using rule 13 (instruction -> .) ]
  ! WHILE           [ reduce using rule 13 (instruction -> .) ]
  ! R_BRACE         [ reduce using rule 13 (instruction -> .) ]

    condition                      shift and go to state 14
    instruction                    shift and go to state 26
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    loop                           shift and go to state 15

state 15

    (12) instruction -> loop .
    (17) instruction -> loop . instruction
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

  ! reduce/reduce conflict for IDENT resolved using rule 12 (instruction -> loop .)
  ! reduce/reduce conflict for RETURN resolved using rule 12 (instruction -> loop .)
  ! reduce/reduce conflict for IF resolved using rule 12 (instruction -> loop .)
  ! reduce/reduce conflict for WHILE resolved using rule 12 (instruction -> loop .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 12 (instruction -> loop .)
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    R_BRACE         reduce using rule 12 (instruction -> loop .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

  ! IDENT           [ reduce using rule 12 (instruction -> loop .) ]
  ! RETURN          [ reduce using rule 12 (instruction -> loop .) ]
  ! IF              [ reduce using rule 12 (instruction -> loop .) ]
  ! WHILE           [ reduce using rule 12 (instruction -> loop .) ]
  ! IDENT           [ reduce using rule 13 (instruction -> .) ]
  ! RETURN          [ reduce using rule 13 (instruction -> .) ]
  ! IF              [ reduce using rule 13 (instruction -> .) ]
  ! WHILE           [ reduce using rule 13 (instruction -> .) ]
  ! R_BRACE         [ reduce using rule 13 (instruction -> .) ]

    loop                           shift and go to state 15
    instruction                    shift and go to state 27
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    condition                      shift and go to state 14

state 16

    (20) assigment -> IDENT . ASSIGN arExpression

    ASSIGN          shift and go to state 28


state 17

    (21) return -> RETURN . arExpression
    (25) arExpression -> . disjunct
    (26) arExpression -> . disjunct OR arExpression
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    arExpression                   shift and go to state 29
    disjunct                       shift and go to state 30
    conjunct                       shift and go to state 31
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 18

    (22) condition -> IF . arExpression L_BRACE instruction R_BRACE
    (23) condition -> IF . arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (25) arExpression -> . disjunct
    (26) arExpression -> . disjunct OR arExpression
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    arExpression                   shift and go to state 43
    disjunct                       shift and go to state 30
    conjunct                       shift and go to state 31
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 19

    (24) loop -> WHILE . arExpression L_BRACE instruction R_BRACE
    (25) arExpression -> . disjunct
    (26) arExpression -> . disjunct OR arExpression
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    arExpression                   shift and go to state 44
    disjunct                       shift and go to state 30
    conjunct                       shift and go to state 31
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 20

    (6) argumentList -> IDENT .
    (7) argumentList -> IDENT . COMMA argumentList

    R_BRACKET       reduce using rule 6 (argumentList -> IDENT .)
    COMMA           shift and go to state 45


state 21

    (4) signature -> IDENT L_BRACKET argumentList . R_BRACKET

    R_BRACKET       shift and go to state 46


state 22

    (3) function -> FUNCTION signature L_BRACE body R_BRACE .

    FUNCTION        reduce using rule 3 (function -> FUNCTION signature L_BRACE body R_BRACE .)
    $end            reduce using rule 3 (function -> FUNCTION signature L_BRACE body R_BRACE .)


state 23

    (18) infinstruction -> infinstruction instruction .

    IDENT           reduce using rule 18 (infinstruction -> infinstruction instruction .)
    RETURN          reduce using rule 18 (infinstruction -> infinstruction instruction .)
    IF              reduce using rule 18 (infinstruction -> infinstruction instruction .)
    WHILE           reduce using rule 18 (infinstruction -> infinstruction instruction .)
    R_BRACE         reduce using rule 18 (infinstruction -> infinstruction instruction .)


state 24

    (14) instruction -> assigment instruction .

    IDENT           reduce using rule 14 (instruction -> assigment instruction .)
    RETURN          reduce using rule 14 (instruction -> assigment instruction .)
    IF              reduce using rule 14 (instruction -> assigment instruction .)
    WHILE           reduce using rule 14 (instruction -> assigment instruction .)
    R_BRACE         reduce using rule 14 (instruction -> assigment instruction .)


state 25

    (15) instruction -> return instruction .

    IDENT           reduce using rule 15 (instruction -> return instruction .)
    RETURN          reduce using rule 15 (instruction -> return instruction .)
    IF              reduce using rule 15 (instruction -> return instruction .)
    WHILE           reduce using rule 15 (instruction -> return instruction .)
    R_BRACE         reduce using rule 15 (instruction -> return instruction .)


state 26

    (16) instruction -> condition instruction .

    IDENT           reduce using rule 16 (instruction -> condition instruction .)
    RETURN          reduce using rule 16 (instruction -> condition instruction .)
    IF              reduce using rule 16 (instruction -> condition instruction .)
    WHILE           reduce using rule 16 (instruction -> condition instruction .)
    R_BRACE         reduce using rule 16 (instruction -> condition instruction .)


state 27

    (17) instruction -> loop instruction .

    IDENT           reduce using rule 17 (instruction -> loop instruction .)
    RETURN          reduce using rule 17 (instruction -> loop instruction .)
    IF              reduce using rule 17 (instruction -> loop instruction .)
    WHILE           reduce using rule 17 (instruction -> loop instruction .)
    R_BRACE         reduce using rule 17 (instruction -> loop instruction .)


state 28

    (20) assigment -> IDENT ASSIGN . arExpression
    (25) arExpression -> . disjunct
    (26) arExpression -> . disjunct OR arExpression
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    arExpression                   shift and go to state 47
    disjunct                       shift and go to state 30
    conjunct                       shift and go to state 31
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 29

    (21) return -> RETURN arExpression .

    IDENT           reduce using rule 21 (return -> RETURN arExpression .)
    RETURN          reduce using rule 21 (return -> RETURN arExpression .)
    IF              reduce using rule 21 (return -> RETURN arExpression .)
    WHILE           reduce using rule 21 (return -> RETURN arExpression .)
    R_BRACE         reduce using rule 21 (return -> RETURN arExpression .)


state 30

    (25) arExpression -> disjunct .
    (26) arExpression -> disjunct . OR arExpression

    IDENT           reduce using rule 25 (arExpression -> disjunct .)
    RETURN          reduce using rule 25 (arExpression -> disjunct .)
    IF              reduce using rule 25 (arExpression -> disjunct .)
    WHILE           reduce using rule 25 (arExpression -> disjunct .)
    R_BRACE         reduce using rule 25 (arExpression -> disjunct .)
    L_BRACE         reduce using rule 25 (arExpression -> disjunct .)
    R_BRACKET       reduce using rule 25 (arExpression -> disjunct .)
    OR              shift and go to state 48


state 31

    (27) disjunct -> conjunct .
    (28) disjunct -> conjunct . AND disjunct

    OR              reduce using rule 27 (disjunct -> conjunct .)
    IDENT           reduce using rule 27 (disjunct -> conjunct .)
    RETURN          reduce using rule 27 (disjunct -> conjunct .)
    IF              reduce using rule 27 (disjunct -> conjunct .)
    WHILE           reduce using rule 27 (disjunct -> conjunct .)
    R_BRACE         reduce using rule 27 (disjunct -> conjunct .)
    L_BRACE         reduce using rule 27 (disjunct -> conjunct .)
    R_BRACKET       reduce using rule 27 (disjunct -> conjunct .)
    AND             shift and go to state 49


state 32

    (29) conjunct -> binaryExp .
    (30) conjunct -> binaryExp . BIN_OP binaryExp

    AND             reduce using rule 29 (conjunct -> binaryExp .)
    OR              reduce using rule 29 (conjunct -> binaryExp .)
    IDENT           reduce using rule 29 (conjunct -> binaryExp .)
    RETURN          reduce using rule 29 (conjunct -> binaryExp .)
    IF              reduce using rule 29 (conjunct -> binaryExp .)
    WHILE           reduce using rule 29 (conjunct -> binaryExp .)
    R_BRACE         reduce using rule 29 (conjunct -> binaryExp .)
    L_BRACE         reduce using rule 29 (conjunct -> binaryExp .)
    R_BRACKET       reduce using rule 29 (conjunct -> binaryExp .)
    BIN_OP          shift and go to state 50


state 33

    (31) binaryExp -> expression .
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term

    BIN_OP          reduce using rule 31 (binaryExp -> expression .)
    AND             reduce using rule 31 (binaryExp -> expression .)
    OR              reduce using rule 31 (binaryExp -> expression .)
    IDENT           reduce using rule 31 (binaryExp -> expression .)
    RETURN          reduce using rule 31 (binaryExp -> expression .)
    IF              reduce using rule 31 (binaryExp -> expression .)
    WHILE           reduce using rule 31 (binaryExp -> expression .)
    R_BRACE         reduce using rule 31 (binaryExp -> expression .)
    L_BRACE         reduce using rule 31 (binaryExp -> expression .)
    R_BRACKET       reduce using rule 31 (binaryExp -> expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 34

    (32) binaryExp -> NOT . expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    expression                     shift and go to state 53
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 35

    (33) expression -> term .
    (37) term -> term . MUL_OP factor

    PLUS            reduce using rule 33 (expression -> term .)
    MINUS           reduce using rule 33 (expression -> term .)
    BIN_OP          reduce using rule 33 (expression -> term .)
    AND             reduce using rule 33 (expression -> term .)
    OR              reduce using rule 33 (expression -> term .)
    IDENT           reduce using rule 33 (expression -> term .)
    RETURN          reduce using rule 33 (expression -> term .)
    IF              reduce using rule 33 (expression -> term .)
    WHILE           reduce using rule 33 (expression -> term .)
    R_BRACE         reduce using rule 33 (expression -> term .)
    L_BRACE         reduce using rule 33 (expression -> term .)
    R_BRACKET       reduce using rule 33 (expression -> term .)
    MUL_OP          shift and go to state 54


state 36

    (39) factor -> MINUS . factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    factor                         shift and go to state 55
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 37

    (36) term -> factor .

    MUL_OP          reduce using rule 36 (term -> factor .)
    PLUS            reduce using rule 36 (term -> factor .)
    MINUS           reduce using rule 36 (term -> factor .)
    BIN_OP          reduce using rule 36 (term -> factor .)
    AND             reduce using rule 36 (term -> factor .)
    OR              reduce using rule 36 (term -> factor .)
    IDENT           reduce using rule 36 (term -> factor .)
    RETURN          reduce using rule 36 (term -> factor .)
    IF              reduce using rule 36 (term -> factor .)
    WHILE           reduce using rule 36 (term -> factor .)
    R_BRACE         reduce using rule 36 (term -> factor .)
    L_BRACE         reduce using rule 36 (term -> factor .)
    R_BRACKET       reduce using rule 36 (term -> factor .)


state 38

    (38) factor -> base .
    (40) factor -> base . FACTOR factor

    MUL_OP          reduce using rule 38 (factor -> base .)
    PLUS            reduce using rule 38 (factor -> base .)
    MINUS           reduce using rule 38 (factor -> base .)
    BIN_OP          reduce using rule 38 (factor -> base .)
    AND             reduce using rule 38 (factor -> base .)
    OR              reduce using rule 38 (factor -> base .)
    IDENT           reduce using rule 38 (factor -> base .)
    RETURN          reduce using rule 38 (factor -> base .)
    IF              reduce using rule 38 (factor -> base .)
    WHILE           reduce using rule 38 (factor -> base .)
    R_BRACE         reduce using rule 38 (factor -> base .)
    L_BRACE         reduce using rule 38 (factor -> base .)
    R_BRACKET       reduce using rule 38 (factor -> base .)
    FACTOR          shift and go to state 56


state 39

    (41) base -> NUMBER .

    FACTOR          reduce using rule 41 (base -> NUMBER .)
    MUL_OP          reduce using rule 41 (base -> NUMBER .)
    PLUS            reduce using rule 41 (base -> NUMBER .)
    MINUS           reduce using rule 41 (base -> NUMBER .)
    BIN_OP          reduce using rule 41 (base -> NUMBER .)
    AND             reduce using rule 41 (base -> NUMBER .)
    OR              reduce using rule 41 (base -> NUMBER .)
    IDENT           reduce using rule 41 (base -> NUMBER .)
    RETURN          reduce using rule 41 (base -> NUMBER .)
    IF              reduce using rule 41 (base -> NUMBER .)
    WHILE           reduce using rule 41 (base -> NUMBER .)
    R_BRACE         reduce using rule 41 (base -> NUMBER .)
    L_BRACE         reduce using rule 41 (base -> NUMBER .)
    R_BRACKET       reduce using rule 41 (base -> NUMBER .)


state 40

    (42) base -> IDENT .
    (4) signature -> IDENT . L_BRACKET argumentList R_BRACKET

    FACTOR          reduce using rule 42 (base -> IDENT .)
    MUL_OP          reduce using rule 42 (base -> IDENT .)
    PLUS            reduce using rule 42 (base -> IDENT .)
    MINUS           reduce using rule 42 (base -> IDENT .)
    BIN_OP          reduce using rule 42 (base -> IDENT .)
    AND             reduce using rule 42 (base -> IDENT .)
    OR              reduce using rule 42 (base -> IDENT .)
    IDENT           reduce using rule 42 (base -> IDENT .)
    RETURN          reduce using rule 42 (base -> IDENT .)
    IF              reduce using rule 42 (base -> IDENT .)
    WHILE           reduce using rule 42 (base -> IDENT .)
    R_BRACE         reduce using rule 42 (base -> IDENT .)
    L_BRACE         reduce using rule 42 (base -> IDENT .)
    R_BRACKET       reduce using rule 42 (base -> IDENT .)
    L_BRACKET       shift and go to state 8


state 41

    (43) base -> L_BRACKET . arExpression R_BRACKET
    (25) arExpression -> . disjunct
    (26) arExpression -> . disjunct OR arExpression
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    arExpression                   shift and go to state 57
    disjunct                       shift and go to state 30
    conjunct                       shift and go to state 31
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 42

    (44) base -> signature .

    FACTOR          reduce using rule 44 (base -> signature .)
    MUL_OP          reduce using rule 44 (base -> signature .)
    PLUS            reduce using rule 44 (base -> signature .)
    MINUS           reduce using rule 44 (base -> signature .)
    BIN_OP          reduce using rule 44 (base -> signature .)
    AND             reduce using rule 44 (base -> signature .)
    OR              reduce using rule 44 (base -> signature .)
    IDENT           reduce using rule 44 (base -> signature .)
    RETURN          reduce using rule 44 (base -> signature .)
    IF              reduce using rule 44 (base -> signature .)
    WHILE           reduce using rule 44 (base -> signature .)
    R_BRACE         reduce using rule 44 (base -> signature .)
    L_BRACE         reduce using rule 44 (base -> signature .)
    R_BRACKET       reduce using rule 44 (base -> signature .)


state 43

    (22) condition -> IF arExpression . L_BRACE instruction R_BRACE
    (23) condition -> IF arExpression . L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE

    L_BRACE         shift and go to state 58


state 44

    (24) loop -> WHILE arExpression . L_BRACE instruction R_BRACE

    L_BRACE         shift and go to state 59


state 45

    (7) argumentList -> IDENT COMMA . argumentList
    (6) argumentList -> . IDENT
    (7) argumentList -> . IDENT COMMA argumentList
    (8) argumentList -> .

    IDENT           shift and go to state 20
    R_BRACKET       reduce using rule 8 (argumentList -> .)

    argumentList                   shift and go to state 60

state 46

    (4) signature -> IDENT L_BRACKET argumentList R_BRACKET .

    L_BRACE         reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    FACTOR          reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    MUL_OP          reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    PLUS            reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    MINUS           reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    BIN_OP          reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    AND             reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    OR              reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    IDENT           reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    RETURN          reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    IF              reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    WHILE           reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    R_BRACE         reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)
    R_BRACKET       reduce using rule 4 (signature -> IDENT L_BRACKET argumentList R_BRACKET .)


state 47

    (20) assigment -> IDENT ASSIGN arExpression .

    IDENT           reduce using rule 20 (assigment -> IDENT ASSIGN arExpression .)
    RETURN          reduce using rule 20 (assigment -> IDENT ASSIGN arExpression .)
    IF              reduce using rule 20 (assigment -> IDENT ASSIGN arExpression .)
    WHILE           reduce using rule 20 (assigment -> IDENT ASSIGN arExpression .)
    R_BRACE         reduce using rule 20 (assigment -> IDENT ASSIGN arExpression .)


state 48

    (26) arExpression -> disjunct OR . arExpression
    (25) arExpression -> . disjunct
    (26) arExpression -> . disjunct OR arExpression
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    disjunct                       shift and go to state 30
    arExpression                   shift and go to state 61
    conjunct                       shift and go to state 31
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 49

    (28) disjunct -> conjunct AND . disjunct
    (27) disjunct -> . conjunct
    (28) disjunct -> . conjunct AND disjunct
    (29) conjunct -> . binaryExp
    (30) conjunct -> . binaryExp BIN_OP binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    conjunct                       shift and go to state 31
    disjunct                       shift and go to state 62
    binaryExp                      shift and go to state 32
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 50

    (30) conjunct -> binaryExp BIN_OP . binaryExp
    (31) binaryExp -> . expression
    (32) binaryExp -> . NOT expression
    (33) expression -> . term
    (34) expression -> . expression PLUS term
    (35) expression -> . expression MINUS term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    NOT             shift and go to state 34
    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    binaryExp                      shift and go to state 63
    expression                     shift and go to state 33
    term                           shift and go to state 35
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 51

    (34) expression -> expression PLUS . term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    term                           shift and go to state 64
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 52

    (35) expression -> expression MINUS . term
    (36) term -> . factor
    (37) term -> . term MUL_OP factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    term                           shift and go to state 65
    factor                         shift and go to state 37
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 53

    (32) binaryExp -> NOT expression .
    (34) expression -> expression . PLUS term
    (35) expression -> expression . MINUS term

    BIN_OP          reduce using rule 32 (binaryExp -> NOT expression .)
    AND             reduce using rule 32 (binaryExp -> NOT expression .)
    OR              reduce using rule 32 (binaryExp -> NOT expression .)
    IDENT           reduce using rule 32 (binaryExp -> NOT expression .)
    RETURN          reduce using rule 32 (binaryExp -> NOT expression .)
    IF              reduce using rule 32 (binaryExp -> NOT expression .)
    WHILE           reduce using rule 32 (binaryExp -> NOT expression .)
    R_BRACE         reduce using rule 32 (binaryExp -> NOT expression .)
    L_BRACE         reduce using rule 32 (binaryExp -> NOT expression .)
    R_BRACKET       reduce using rule 32 (binaryExp -> NOT expression .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 54

    (37) term -> term MUL_OP . factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    factor                         shift and go to state 66
    base                           shift and go to state 38
    signature                      shift and go to state 42

state 55

    (39) factor -> MINUS factor .

    MUL_OP          reduce using rule 39 (factor -> MINUS factor .)
    PLUS            reduce using rule 39 (factor -> MINUS factor .)
    MINUS           reduce using rule 39 (factor -> MINUS factor .)
    BIN_OP          reduce using rule 39 (factor -> MINUS factor .)
    AND             reduce using rule 39 (factor -> MINUS factor .)
    OR              reduce using rule 39 (factor -> MINUS factor .)
    IDENT           reduce using rule 39 (factor -> MINUS factor .)
    RETURN          reduce using rule 39 (factor -> MINUS factor .)
    IF              reduce using rule 39 (factor -> MINUS factor .)
    WHILE           reduce using rule 39 (factor -> MINUS factor .)
    R_BRACE         reduce using rule 39 (factor -> MINUS factor .)
    L_BRACE         reduce using rule 39 (factor -> MINUS factor .)
    R_BRACKET       reduce using rule 39 (factor -> MINUS factor .)


state 56

    (40) factor -> base FACTOR . factor
    (38) factor -> . base
    (39) factor -> . MINUS factor
    (40) factor -> . base FACTOR factor
    (41) base -> . NUMBER
    (42) base -> . IDENT
    (43) base -> . L_BRACKET arExpression R_BRACKET
    (44) base -> . signature
    (4) signature -> . IDENT L_BRACKET argumentList R_BRACKET

    MINUS           shift and go to state 36
    NUMBER          shift and go to state 39
    IDENT           shift and go to state 40
    L_BRACKET       shift and go to state 41

    base                           shift and go to state 38
    factor                         shift and go to state 67
    signature                      shift and go to state 42

state 57

    (43) base -> L_BRACKET arExpression . R_BRACKET

    R_BRACKET       shift and go to state 68


state 58

    (22) condition -> IF arExpression L_BRACE . instruction R_BRACE
    (23) condition -> IF arExpression L_BRACE . instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

    R_BRACE         reduce using rule 13 (instruction -> .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

    instruction                    shift and go to state 69
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 59

    (24) loop -> WHILE arExpression L_BRACE . instruction R_BRACE
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

    R_BRACE         reduce using rule 13 (instruction -> .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

    instruction                    shift and go to state 70
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 60

    (7) argumentList -> IDENT COMMA argumentList .

    R_BRACKET       reduce using rule 7 (argumentList -> IDENT COMMA argumentList .)


state 61

    (26) arExpression -> disjunct OR arExpression .

    IDENT           reduce using rule 26 (arExpression -> disjunct OR arExpression .)
    RETURN          reduce using rule 26 (arExpression -> disjunct OR arExpression .)
    IF              reduce using rule 26 (arExpression -> disjunct OR arExpression .)
    WHILE           reduce using rule 26 (arExpression -> disjunct OR arExpression .)
    R_BRACE         reduce using rule 26 (arExpression -> disjunct OR arExpression .)
    L_BRACE         reduce using rule 26 (arExpression -> disjunct OR arExpression .)
    R_BRACKET       reduce using rule 26 (arExpression -> disjunct OR arExpression .)


state 62

    (28) disjunct -> conjunct AND disjunct .

    OR              reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    IDENT           reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    RETURN          reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    IF              reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    WHILE           reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    R_BRACE         reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    L_BRACE         reduce using rule 28 (disjunct -> conjunct AND disjunct .)
    R_BRACKET       reduce using rule 28 (disjunct -> conjunct AND disjunct .)


state 63

    (30) conjunct -> binaryExp BIN_OP binaryExp .

    AND             reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    OR              reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    IDENT           reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    RETURN          reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    IF              reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    WHILE           reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    R_BRACE         reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    L_BRACE         reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)
    R_BRACKET       reduce using rule 30 (conjunct -> binaryExp BIN_OP binaryExp .)


state 64

    (34) expression -> expression PLUS term .
    (37) term -> term . MUL_OP factor

    PLUS            reduce using rule 34 (expression -> expression PLUS term .)
    MINUS           reduce using rule 34 (expression -> expression PLUS term .)
    BIN_OP          reduce using rule 34 (expression -> expression PLUS term .)
    AND             reduce using rule 34 (expression -> expression PLUS term .)
    OR              reduce using rule 34 (expression -> expression PLUS term .)
    IDENT           reduce using rule 34 (expression -> expression PLUS term .)
    RETURN          reduce using rule 34 (expression -> expression PLUS term .)
    IF              reduce using rule 34 (expression -> expression PLUS term .)
    WHILE           reduce using rule 34 (expression -> expression PLUS term .)
    R_BRACE         reduce using rule 34 (expression -> expression PLUS term .)
    L_BRACE         reduce using rule 34 (expression -> expression PLUS term .)
    R_BRACKET       reduce using rule 34 (expression -> expression PLUS term .)
    MUL_OP          shift and go to state 54


state 65

    (35) expression -> expression MINUS term .
    (37) term -> term . MUL_OP factor

    PLUS            reduce using rule 35 (expression -> expression MINUS term .)
    MINUS           reduce using rule 35 (expression -> expression MINUS term .)
    BIN_OP          reduce using rule 35 (expression -> expression MINUS term .)
    AND             reduce using rule 35 (expression -> expression MINUS term .)
    OR              reduce using rule 35 (expression -> expression MINUS term .)
    IDENT           reduce using rule 35 (expression -> expression MINUS term .)
    RETURN          reduce using rule 35 (expression -> expression MINUS term .)
    IF              reduce using rule 35 (expression -> expression MINUS term .)
    WHILE           reduce using rule 35 (expression -> expression MINUS term .)
    R_BRACE         reduce using rule 35 (expression -> expression MINUS term .)
    L_BRACE         reduce using rule 35 (expression -> expression MINUS term .)
    R_BRACKET       reduce using rule 35 (expression -> expression MINUS term .)
    MUL_OP          shift and go to state 54


state 66

    (37) term -> term MUL_OP factor .

    MUL_OP          reduce using rule 37 (term -> term MUL_OP factor .)
    PLUS            reduce using rule 37 (term -> term MUL_OP factor .)
    MINUS           reduce using rule 37 (term -> term MUL_OP factor .)
    BIN_OP          reduce using rule 37 (term -> term MUL_OP factor .)
    AND             reduce using rule 37 (term -> term MUL_OP factor .)
    OR              reduce using rule 37 (term -> term MUL_OP factor .)
    IDENT           reduce using rule 37 (term -> term MUL_OP factor .)
    RETURN          reduce using rule 37 (term -> term MUL_OP factor .)
    IF              reduce using rule 37 (term -> term MUL_OP factor .)
    WHILE           reduce using rule 37 (term -> term MUL_OP factor .)
    R_BRACE         reduce using rule 37 (term -> term MUL_OP factor .)
    L_BRACE         reduce using rule 37 (term -> term MUL_OP factor .)
    R_BRACKET       reduce using rule 37 (term -> term MUL_OP factor .)


state 67

    (40) factor -> base FACTOR factor .

    MUL_OP          reduce using rule 40 (factor -> base FACTOR factor .)
    PLUS            reduce using rule 40 (factor -> base FACTOR factor .)
    MINUS           reduce using rule 40 (factor -> base FACTOR factor .)
    BIN_OP          reduce using rule 40 (factor -> base FACTOR factor .)
    AND             reduce using rule 40 (factor -> base FACTOR factor .)
    OR              reduce using rule 40 (factor -> base FACTOR factor .)
    IDENT           reduce using rule 40 (factor -> base FACTOR factor .)
    RETURN          reduce using rule 40 (factor -> base FACTOR factor .)
    IF              reduce using rule 40 (factor -> base FACTOR factor .)
    WHILE           reduce using rule 40 (factor -> base FACTOR factor .)
    R_BRACE         reduce using rule 40 (factor -> base FACTOR factor .)
    L_BRACE         reduce using rule 40 (factor -> base FACTOR factor .)
    R_BRACKET       reduce using rule 40 (factor -> base FACTOR factor .)


state 68

    (43) base -> L_BRACKET arExpression R_BRACKET .

    FACTOR          reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    MUL_OP          reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    PLUS            reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    MINUS           reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    BIN_OP          reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    AND             reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    OR              reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    IDENT           reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    RETURN          reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    IF              reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    WHILE           reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    R_BRACE         reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    L_BRACE         reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)
    R_BRACKET       reduce using rule 43 (base -> L_BRACKET arExpression R_BRACKET .)


state 69

    (22) condition -> IF arExpression L_BRACE instruction . R_BRACE
    (23) condition -> IF arExpression L_BRACE instruction . R_BRACE ELSE L_BRACE instruction R_BRACE

    R_BRACE         shift and go to state 71


state 70

    (24) loop -> WHILE arExpression L_BRACE instruction . R_BRACE

    R_BRACE         shift and go to state 72


state 71

    (22) condition -> IF arExpression L_BRACE instruction R_BRACE .
    (23) condition -> IF arExpression L_BRACE instruction R_BRACE . ELSE L_BRACE instruction R_BRACE

    IDENT           reduce using rule 22 (condition -> IF arExpression L_BRACE instruction R_BRACE .)
    RETURN          reduce using rule 22 (condition -> IF arExpression L_BRACE instruction R_BRACE .)
    IF              reduce using rule 22 (condition -> IF arExpression L_BRACE instruction R_BRACE .)
    WHILE           reduce using rule 22 (condition -> IF arExpression L_BRACE instruction R_BRACE .)
    R_BRACE         reduce using rule 22 (condition -> IF arExpression L_BRACE instruction R_BRACE .)
    ELSE            shift and go to state 73


state 72

    (24) loop -> WHILE arExpression L_BRACE instruction R_BRACE .

    IDENT           reduce using rule 24 (loop -> WHILE arExpression L_BRACE instruction R_BRACE .)
    RETURN          reduce using rule 24 (loop -> WHILE arExpression L_BRACE instruction R_BRACE .)
    IF              reduce using rule 24 (loop -> WHILE arExpression L_BRACE instruction R_BRACE .)
    WHILE           reduce using rule 24 (loop -> WHILE arExpression L_BRACE instruction R_BRACE .)
    R_BRACE         reduce using rule 24 (loop -> WHILE arExpression L_BRACE instruction R_BRACE .)


state 73

    (23) condition -> IF arExpression L_BRACE instruction R_BRACE ELSE . L_BRACE instruction R_BRACE

    L_BRACE         shift and go to state 74


state 74

    (23) condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE . instruction R_BRACE
    (9) instruction -> . assigment
    (10) instruction -> . return
    (11) instruction -> . condition
    (12) instruction -> . loop
    (13) instruction -> .
    (14) instruction -> . assigment instruction
    (15) instruction -> . return instruction
    (16) instruction -> . condition instruction
    (17) instruction -> . loop instruction
    (20) assigment -> . IDENT ASSIGN arExpression
    (21) return -> . RETURN arExpression
    (22) condition -> . IF arExpression L_BRACE instruction R_BRACE
    (23) condition -> . IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE
    (24) loop -> . WHILE arExpression L_BRACE instruction R_BRACE

    R_BRACE         reduce using rule 13 (instruction -> .)
    IDENT           shift and go to state 16
    RETURN          shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19

    instruction                    shift and go to state 75
    assigment                      shift and go to state 12
    return                         shift and go to state 13
    condition                      shift and go to state 14
    loop                           shift and go to state 15

state 75

    (23) condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction . R_BRACE

    R_BRACE         shift and go to state 76


state 76

    (23) condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE .

    IDENT           reduce using rule 23 (condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE .)
    RETURN          reduce using rule 23 (condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE .)
    IF              reduce using rule 23 (condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE .)
    WHILE           reduce using rule 23 (condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE .)
    R_BRACE         reduce using rule 23 (condition -> IF arExpression L_BRACE instruction R_BRACE ELSE L_BRACE instruction R_BRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENT in state 7 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 7 resolved as shift
WARNING: shift/reduce conflict for IF in state 7 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 7 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 10 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 10 resolved as shift
WARNING: shift/reduce conflict for IF in state 10 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 10 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 12 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 12 resolved as shift
WARNING: shift/reduce conflict for IF in state 12 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 12 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 13 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 13 resolved as shift
WARNING: shift/reduce conflict for IF in state 13 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 13 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 14 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 14 resolved as shift
WARNING: shift/reduce conflict for IF in state 14 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 14 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 15 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 15 resolved as shift
WARNING: shift/reduce conflict for IF in state 15 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 15 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (body -> infinstruction)
WARNING: rejected rule (instruction -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 12 resolved using rule (instruction -> assigment)
WARNING: rejected rule (instruction -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 13 resolved using rule (instruction -> return)
WARNING: rejected rule (instruction -> <empty>) in state 13
WARNING: reduce/reduce conflict in state 14 resolved using rule (instruction -> condition)
WARNING: rejected rule (instruction -> <empty>) in state 14
WARNING: reduce/reduce conflict in state 15 resolved using rule (instruction -> loop)
WARNING: rejected rule (instruction -> <empty>) in state 15
